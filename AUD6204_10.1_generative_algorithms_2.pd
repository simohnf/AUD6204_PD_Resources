#N canvas 206 48 476 408 10;
#X text 315 362 sjf \, SAE London \, 2020;
#X text 88 106 Firstly \, go to Media >> Audio Settings and ensure
your drivers are set correctly;
#X text 89 132 Turn on DSP from the PD Window;
#X text 80 164 ------------------------------------------------------------
;
#X text 89 6 For this lesson we will look at some more generative algorithms
;
#X text 92 182 We'll start by looking at a simple rhythm generator
;
#N canvas -1334 636 1103 662 2s_or_3s 0;
#X text 74 15 This is based on the simple idea that many rhythms can
be broken down into groups of 2s and 3s;
#X text 73 41 For example a classic 4/4 back beat has kick on 1 & 3
\, and snare on 2 & 4;
#X text 72 105 But we could also group a bar of 4/4/ (i.e. eight 8th
notes) as 2 groups of 3 \, followed by a group of 2 (3 3 2);
#X text 72 64 If we look at that as an 1/8th note pattern it is simply
4 groups of 2 (2 2 2 2);
#X text 76 133 Or any other permutation of this - i.e. 3 2 3 or 2 3
3;
#X text 71 265 Firstly what we want to do is randomly generate a 2
or a 3;
#N canvas -1280 581 1208 642 nBeats_logic 0;
#X text 31 14 If we're using groups of 2 or 3 there are 5 scenarios
we need to consider;
#X text 66 44 if there are 0 beats left we have created one complete
bar;
#X text 64 60 if there is 1 beat left we have a problem because we
can only create groups of 2/3 beats;
#X text 63 88 if there are 2 beats left we have to create a group of
2;
#X text 63 104 if there are 3 beats left we have to create a group
of 3;
#X text 64 143 In every other scenario can can generate a 2 or 3 randomly
;
#N canvas 0 23 347 197 random_2_or_3 0;
#X obj 103 51 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 103 71 random 2;
#X obj 103 92 + 2;
#X text 157 72 <-- random 0 or 1;
#X text 133 93 <-- random 2 or 3;
#X obj 101 30 inlet;
#X obj 103 133 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 5 0 0 0;
#X restore 1010 348 pd random_2_or_3;
#X f 9;
#X obj 1010 325 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 1010 391 5 0 0 0 - - -;
#X obj 981 468 +, f 17;
#X obj 981 492 int;
#X floatatom 981 513 5 0 0 0 running_total - -;
#X msg 1080 102 0;
#X text 59 168 We can just hard code this using select;
#X obj 721 286 sel 0 1 2 3 4, f 54;
#X msg 913 325 2;
#X msg 943 325 3;
#X obj 721 408 print done;
#X obj 788 374 print problem;
#X text 63 119 if there are 4 beats left we have to create 2 (that
leaves 2 beats left!);
#X msg 973 325 2;
#X obj 721 191 -, f 5;
#X obj 721 171 int;
#X obj 741 133 t b f;
#X floatatom 721 212 5 0 0 0 beats_remaining - -;
#X floatatom 497 59 5 0 0 0 nBeats - -;
#X text 533 56 # of beats to generate;
#X obj 497 8 loadbang;
#X msg 497 29 16;
#X obj 981 581 print beatsGenerated;
#X text 1106 103 reset counters;
#X text 573 286 Harcoded scenarios ---->;
#X obj 719 37 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X text 741 36 Bang to start;
#X obj 719 73 t b b, f 60;
#X text 43 206 NOTE: the beats generated never include beat 0 (i.e.
the first beat) we will need to correct for this later;
#X connect 6 0 8 0;
#X connect 7 0 6 0;
#X connect 8 0 9 0;
#X connect 9 0 10 0;
#X connect 10 0 9 1;
#X connect 10 0 11 0;
#X connect 11 0 29 0;
#X connect 11 0 23 0;
#X connect 12 0 9 1;
#X connect 12 0 21 1;
#X connect 14 0 17 0;
#X connect 14 1 18 0;
#X connect 14 2 15 0;
#X connect 14 3 16 0;
#X connect 14 4 20 0;
#X connect 14 5 7 0;
#X connect 15 0 9 0;
#X connect 16 0 9 0;
#X connect 20 0 9 0;
#X connect 21 0 24 0;
#X connect 22 0 21 0;
#X connect 23 0 22 0;
#X connect 23 1 21 1;
#X connect 24 0 14 0;
#X connect 25 0 22 1;
#X connect 27 0 28 0;
#X connect 28 0 25 0;
#X connect 32 0 34 0;
#X connect 34 0 22 0;
#X connect 34 1 12 0;
#X restore 88 489 pd nBeats_logic;
#X text 72 447 We need a way of making sure our pattern fits into the
number of beats in the bar;
#N canvas -568 614 450 300 random2/3 0;
#N canvas 0 23 347 197 random_2_or_3 0;
#X obj 103 51 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 103 71 random 2;
#X obj 103 92 + 2;
#X text 157 72 <-- random 0 or 1;
#X text 133 93 <-- random 2 or 3;
#X obj 101 30 inlet;
#X obj 103 133 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 5 0 0 0;
#X restore 106 102 pd random_2_or_3;
#X obj 107 82 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 106 123 5 0 0 0 - - -;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X restore 102 289 pd random2/3;
#X text 73 325 We will need a way of keeping a running total (so if
we've generated two groups of 3 we need to know that that is 6 beats)
;
#N canvas -1095 581 622 581 running_total_logic 0;
#X text 47 36 we want to make sure our total is always equal to the
number of beats in a bar (so \, for exampl \, we dont want to end up
with a pattern of "2 2 3 2" (i.e. 9 beats) if there are only 8 beats
in the bar;
#X text 42 101 We will need to keep a running total (think counter)
of the number of beats our pattern covers \, and then work out how
many beats are left;
#N canvas 0 23 347 197 random_2_or_3 0;
#X obj 103 51 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 103 71 random 2;
#X obj 103 92 + 2;
#X text 157 72 <-- random 0 or 1;
#X text 133 93 <-- random 2 or 3;
#X obj 101 30 inlet;
#X obj 103 133 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 5 0 0 0;
#X restore 176 177 pd random_2_or_3;
#X obj 177 157 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 176 198 5 0 0 0 - - -;
#X obj 176 326 +;
#X obj 176 350 int;
#X floatatom 176 371 5 0 0 0 running_total - -;
#X msg 314 281 0;
#X text 346 282 reset;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 5 1;
#X connect 6 0 7 0;
#X connect 8 0 5 1;
#X restore 87 366 pd running_total_logic;
#X text 74 161 But I want my algorithm to be capable of doing this
for any number of beats;
#X text 83 186 e.g. 9 beats could be groupped as 3 3 3 \, or any permutation
of thre 2s and a 3 (e.g. 2 2 2 3);
#N canvas -852 733 1059 675 final 0;
#N canvas 0 23 347 197 random_2_or_3 0;
#X obj 103 51 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 103 71 random 2;
#X obj 103 92 + 2;
#X text 157 72 <-- random 0 or 1;
#X text 133 93 <-- random 2 or 3;
#X obj 101 30 inlet;
#X obj 103 133 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 5 0 0 0;
#X restore 458 345 pd random_2_or_3;
#X f 7;
#X obj 458 322 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 458 388 5 0 0 0 - - -;
#X obj 466 470 +, f 17;
#X obj 466 494 int;
#X floatatom 466 515 5 0 0 0 running_total - -;
#X msg 427 143 0;
#X obj 206 288 sel 0 1 2 3 4, f 41;
#X msg 361 322 2;
#X msg 391 322 3;
#X obj 206 410 print done;
#X obj 273 376 print problem;
#X msg 421 322 2;
#X obj 206 193 -, f 5;
#X obj 206 173 int;
#X obj 226 148 t b f;
#X floatatom 206 214 5 0 0 0 beats_remaining - -;
#X floatatom 847 105 5 0 0 0 nBeats - -;
#X text 883 102 # of beats to generate;
#X obj 847 54 loadbang;
#X msg 847 75 16;
#X text 453 142 reset counters;
#X text 58 288 Harcoded scenarios ---->;
#X obj 205 78 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X text 226 77 Bang to start;
#X text 195 6 We can \, of course \, just store our pattern in an array
;
#X text 610 545 The final beat created \, is always the first beat
of the next bar so we can just use modulo to wrapback to the beginning
;
#X obj 467 567 %, f 8;
#X msg 467 605 1 \$1;
#X obj 847 125 s \$0-nBeats;
#X obj 128 127 r \$0-nBeats;
#X obj 528 541 r \$0-nBeats;
#X obj 467 626 tabwrite \$0-2sN3s;
#X text 195 20 but we need to remember to clear the array each time
;
#X obj 205 114 t b b b, f 69;
#X obj 466 535 t f f;
#X obj 687 245 array size \$0-2sN3s;
#X obj 687 194 int;
#X obj 704 173 r \$0-nBeats;
#X msg 687 219 \$1;
#X obj 565 191 int \$0;
#X msg 561 235 \; \$1-2sN3s const 0;
#X obj 205 49 inlet;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 3 1;
#X connect 4 0 5 0;
#X connect 5 0 35 0;
#X connect 6 0 3 1;
#X connect 6 0 13 1;
#X connect 7 0 10 0;
#X connect 7 1 11 0;
#X connect 7 2 8 0;
#X connect 7 3 9 0;
#X connect 7 4 12 0;
#X connect 7 5 1 0;
#X connect 8 0 3 0;
#X connect 9 0 3 0;
#X connect 12 0 3 0;
#X connect 13 0 16 0;
#X connect 14 0 13 0;
#X connect 15 0 14 0;
#X connect 15 1 13 1;
#X connect 16 0 7 0;
#X connect 17 0 29 0;
#X connect 19 0 20 0;
#X connect 20 0 17 0;
#X connect 23 0 34 0;
#X connect 27 0 28 0;
#X connect 28 0 32 0;
#X connect 30 0 14 1;
#X connect 31 0 27 1;
#X connect 34 0 14 0;
#X connect 34 1 6 0;
#X connect 34 2 37 0;
#X connect 34 2 40 0;
#X connect 35 0 15 0;
#X connect 35 1 27 0;
#X connect 37 0 39 0;
#X connect 38 0 37 1;
#X connect 39 0 36 0;
#X connect 40 0 41 0;
#X connect 42 0 23 0;
#X restore 96 575 pd final;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-2sN3s 16 float 3;
#A 0 1 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0;
#X coords 0 1 16 0 200 40 1 0 0;
#X restore 508 55 graph;
#X obj 541 280 tabread \$0-2sN3s;
#X obj 541 308 sel 1;
#X obj 541 329 counter_sjf 2;
#X obj 515 451 kick_sjf~;
#X obj 717 451 snr_sjf~;
#X obj 650 578 vol_sjf~;
#X obj 650 618 dac~;
#X obj 515 430 route 0 1, f 69;
#X obj 541 350 pack, f 41;
#X obj 762 267 sel 0;
#X msg 762 288 100;
#X obj 1001 451 hh_sjf~;
#X obj 541 178 conductor_sjf 175 16;
#X text 72 388 We also need to figure out how many beats are left;
#N canvas 0 239 611 535 running_total_logic2 0;
#N canvas 0 23 347 197 random_2_or_3 0;
#X obj 103 51 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 103 71 random 2;
#X obj 103 92 + 2;
#X text 157 72 <-- random 0 or 1;
#X text 133 93 <-- random 2 or 3;
#X obj 101 30 inlet;
#X obj 103 133 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 5 0 0 0;
#X restore 285 114 pd random_2_or_3;
#X obj 286 94 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 285 135 5 0 0 0 - - -;
#X obj 285 155 +;
#X obj 285 179 int;
#X floatatom 285 200 5 0 0 0 running_total - -;
#X msg 423 110 0;
#X text 455 111 reset;
#X obj 248 440 -, f 12;
#X obj 248 420 int;
#X obj 285 356 t b f, f 6;
#X floatatom 248 461 5 0 0 0 beats_remaining - -;
#X floatatom 60 326 5 0 0 0 nBeats - -;
#X text 96 323 # of beats to generate;
#X obj 60 220 loadbang;
#X msg 60 241 16;
#X text 47 36 Once we know how many beats we've generated \, we just
need to subtract this from the number of beats we want to generate
in total to find out how many are left;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 3 1;
#X connect 4 0 5 0;
#X connect 5 0 10 0;
#X connect 6 0 3 1;
#X connect 6 0 8 1;
#X connect 8 0 11 0;
#X connect 9 0 8 0;
#X connect 10 0 9 0;
#X connect 10 1 8 1;
#X connect 12 0 9 1;
#X connect 14 0 15 0;
#X connect 15 0 12 0;
#X restore 85 410 pd running_total_logic2;
#X text 64 523 Finally we need a way of storing the generated pattern
;
#X obj 708 153 r \$0-nBeats;
#X obj 96 551 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 541 243 t f f f, f 75;
#X obj 951 284 tabread \$0-2sN3s;
#X obj 951 312 sel 1;
#X msg 949 334 100;
#X msg 986 336 30;
#X msg 795 288 30;
#X connect 15 0 16 0;
#X connect 16 0 17 0;
#X connect 17 0 23 0;
#X connect 18 0 20 0;
#X connect 19 0 20 0;
#X connect 20 0 21 0;
#X connect 20 0 21 1;
#X connect 22 0 18 0;
#X connect 22 1 19 0;
#X connect 23 0 22 0;
#X connect 24 0 25 0;
#X connect 24 1 38 0;
#X connect 25 0 23 1;
#X connect 26 0 20 0;
#X connect 27 0 33 0;
#X connect 31 0 27 2;
#X connect 32 0 13 0;
#X connect 33 0 15 0;
#X connect 33 1 24 0;
#X connect 33 2 34 0;
#X connect 34 0 35 0;
#X connect 35 0 36 0;
#X connect 35 1 37 0;
#X connect 36 0 26 0;
#X connect 37 0 26 0;
#X connect 38 0 23 1;
#X restore 105 204 pd 2s_or_3s;
#X text 81 226 ------------------------------------------------------------
;
#X text 107 243 Integer Sequences;
#N canvas -878 596 450 300 integer_sequences 0;
#X text 64 53 Norgards Infinite Series;
#N canvas -907 622 916 619 infinite_series 0;
#X text 83 9 Per Norgard is a Danish composer who developed what he
called the "Infinite Series";
#X text 84 37 This is essentially a pattern follows verysimple rules
to create a chaotic and unpredictable result;
#X text 84 63 However \, there are also numerous patterns that return
continuously leading to the pattern having a fractal (self-similar)
nature;
#X text 86 100 An explanation of the series \, as it relates to musical
intervals can be found here:;
#X text 89 160 But the mathematical foundation is actually an easier
way to approach writing it as code;
#X text 88 213 There are three rule determining the output at any step:
;
#X text 88 198 https://math.usask.ca/~au/AuDS17a.pdf;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-norgard 40 float 3;
#A 0 0 1 -1 2 1 0 -2 3 -1 2 -0 1 2 -1 -3 4 1 0 -2 3 0 1 -1 2 -2 3 1
0 3 -2 -4 5 -1 2 -0 1 2 -1 -3 4;
#X coords 0 12 40 -12 200 140 1 0 0;
#X restore 600 85 graph;
#X text 555 12 I've limited this to 100 steps \, but it does go on
for ever \, very gradually moving away from 0;
#X obj 129 310 conductor_sjf 250 100;
#N canvas 0 23 766 543 norgard_Cmajor 0;
#X text 22 15 Most of us don't really wanna sit and listen to the chromatic
scale all the time \, but this series can be easily mapped onto any
scale;
#X obj 495 253 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X msg 495 273 major;
#N canvas 169 288 750 444 change_the_scale 0;
#X obj 24 20 inlet;
#N canvas 382 323 674 234 Cmajor 0;
#X obj 54 76 sel 0 1 2 3 4 5 6 7;
#X obj 54 14 inlet;
#X obj 54 182 outlet;
#X text -154 122 '0' is equivalent to MIDI note C;
#X text 296 122 '12' is equivalent to MIDI note C1;
#X msg 257 121 12;
#X msg 229 121 11;
#X msg 200 121 9;
#X msg 170 121 7;
#X msg 141 121 5;
#X msg 112 121 4;
#X msg 83 121 2;
#X msg 54 121 0;
#X connect 0 0 12 0;
#X connect 0 1 11 0;
#X connect 0 2 10 0;
#X connect 0 3 9 0;
#X connect 0 4 8 0;
#X connect 0 5 7 0;
#X connect 0 6 6 0;
#X connect 0 7 5 0;
#X connect 1 0 0 0;
#X connect 5 0 2 0;
#X connect 6 0 2 0;
#X connect 7 0 2 0;
#X connect 8 0 2 0;
#X connect 9 0 2 0;
#X connect 10 0 2 0;
#X connect 11 0 2 0;
#X connect 12 0 2 0;
#X restore 16 176 pd Cmajor;
#X obj 51 141 t f f;
#X obj 57 211 pack;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-scale_in_C 8 float 3;
#A 0 0 2 4 5 7 9 11 12;
#X coords 0 12 8 0 200 140 1 0 0;
#X restore 532 29 graph;
#X obj 166 19 inlet;
#X obj 193 140 t f f;
#X obj 199 210 pack;
#N canvas 382 323 674 234 Charmonicminor 0;
#X obj 54 76 sel 0 1 2 3 4 5 6 7;
#X obj 54 14 inlet;
#X obj 54 182 outlet;
#X text -154 122 '0' is equivalent to MIDI note C;
#X text 296 122 '12' is equivalent to MIDI note C1;
#X msg 257 121 12;
#X msg 229 121 11;
#X msg 170 121 7;
#X msg 141 121 5;
#X msg 83 121 2;
#X msg 54 121 0;
#X msg 112 121 3;
#X msg 200 121 8;
#X connect 0 0 10 0;
#X connect 0 1 9 0;
#X connect 0 2 11 0;
#X connect 0 3 8 0;
#X connect 0 4 7 0;
#X connect 0 5 12 0;
#X connect 0 6 6 0;
#X connect 0 7 5 0;
#X connect 1 0 0 0;
#X connect 5 0 2 0;
#X connect 6 0 2 0;
#X connect 7 0 2 0;
#X connect 8 0 2 0;
#X connect 9 0 2 0;
#X connect 10 0 2 0;
#X connect 11 0 2 0;
#X connect 12 0 2 0;
#X restore 158 175 pd Charmonicminor;
#X obj 317 19 inlet;
#X obj 344 140 t f f;
#X obj 350 210 pack;
#N canvas 382 323 674 234 Caltereddominant 0;
#X obj 54 76 sel 0 1 2 3 4 5 6 7;
#X obj 54 14 inlet;
#X obj 54 182 outlet;
#X text -154 122 '0' is equivalent to MIDI note C;
#X text 296 122 '12' is equivalent to MIDI note C1;
#X msg 257 121 12;
#X msg 54 121 0;
#X msg 112 121 3;
#X msg 200 121 8;
#X msg 83 121 1;
#X msg 141 121 4;
#X msg 170 122 6;
#X msg 229 121 10;
#X connect 0 0 6 0;
#X connect 0 1 9 0;
#X connect 0 2 7 0;
#X connect 0 3 10 0;
#X connect 0 4 11 0;
#X connect 0 5 8 0;
#X connect 0 6 12 0;
#X connect 0 7 5 0;
#X connect 1 0 0 0;
#X connect 5 0 2 0;
#X connect 6 0 2 0;
#X connect 7 0 2 0;
#X connect 8 0 2 0;
#X connect 9 0 2 0;
#X connect 10 0 2 0;
#X connect 11 0 2 0;
#X connect 12 0 2 0;
#X restore 314 175 pd Caltereddominant;
#X text 67 324 I start every scale on C so that the first note is always
0 \, and the last is always 12;
#X text 66 354 This just makes transposition to different keys easier
;
#X obj 24 82 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 24 101 pd simpleCounter;
#X obj 24 61 t f f 0, f 16;
#X msg 24 41 8;
#X obj 166 80 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 166 99 pd simpleCounter;
#X obj 166 59 t f f 0, f 16;
#X msg 166 39 8;
#X obj 317 78 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 317 97 pd simpleCounter;
#X obj 317 57 t f f 0, f 16;
#X msg 317 37 8;
#X obj 57 281 tabwrite \$0-scale_in_C;
#X connect 0 0 18 0;
#X connect 1 0 3 0;
#X connect 2 0 1 0;
#X connect 2 1 3 1;
#X connect 3 0 27 0;
#X connect 5 0 22 0;
#X connect 6 0 8 0;
#X connect 6 1 7 1;
#X connect 7 0 27 0;
#X connect 8 0 7 0;
#X connect 9 0 26 0;
#X connect 10 0 12 0;
#X connect 10 1 11 1;
#X connect 11 0 27 0;
#X connect 12 0 11 0;
#X connect 15 0 16 0;
#X connect 16 0 2 0;
#X connect 17 0 15 0;
#X connect 17 1 16 1;
#X connect 17 2 16 2;
#X connect 18 0 17 0;
#X connect 19 0 20 0;
#X connect 20 0 6 0;
#X connect 21 0 19 0;
#X connect 21 1 20 1;
#X connect 21 2 20 2;
#X connect 22 0 21 0;
#X connect 23 0 24 0;
#X connect 24 0 10 0;
#X connect 25 0 23 0;
#X connect 25 1 24 1;
#X connect 25 2 24 2;
#X connect 26 0 25 0;
#X restore 495 295 pd change_the_scale;
#X obj 537 253 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 637 253 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X msg 537 273 harmonic minor;
#X msg 637 273 altered dominant;
#X text 618 294 <---- click me;
#X obj 46 347 tabread \$0-scale_in_C;
#X obj 47 236 t f f;
#X obj 47 257 < 0;
#X obj 47 278 pack, f 5;
#X obj 47 299 route 0 1, f 64;
#X obj 213 394 tabread \$0-scale_in_C;
#X obj 213 415 - 12;
#X obj 213 330 + 7;
#X text 238 330 there are 8 possible values in my scale \, but the
final one is the octave so I discount it;
#X text 237 353 As such \, adding 7 merely raises any negative values
to within the range of the array the scale is stored in;
#X text 242 414 I need to drop them back down an octave;
#X text 21 109 Here I am just recycling some of my earlier code so
I can reference different scale;
#X text 397 11 I haven't even begun playing with rhythm yet \, but
experiment with using this series to control other parameters than
pitch...;
#X text 396 54 Or try reading the series multiple times (out of phase
or at different speeds etc) to create polyphonic patterns;
#X text 22 48 By simply using the values stored at each step to represent
notes in the scale (i.e. 0==root \; 7 == 7th \; -1 == 7th below root
\; 2 == 2nd etc);
#X obj 47 194 inlet;
#X obj 46 507 outlet;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 4 0 6 0;
#X connect 5 0 7 0;
#X connect 6 0 3 1;
#X connect 7 0 3 2;
#X connect 9 0 25 0;
#X connect 10 0 11 0;
#X connect 10 1 12 1;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 13 0 9 0;
#X connect 13 1 16 0;
#X connect 14 0 15 0;
#X connect 15 0 25 0;
#X connect 16 0 14 0;
#X connect 24 0 10 0;
#X restore 153 514 pd norgard_Cmajor;
#X text 37 349 play me -->;
#X text 85 125 https://www.lawtonhall.com/av-diary/2019/9/9/per-nrgrds-infinity-series
;
#X text 134 238 a(n) = 0 \, if n = 0 \; −a(n/2) \, if n is even \;
a( (n−1) / 2 ) + 1 \, if n is odd.;
#X obj 128 542 + 60;
#X obj 128 563 makenote 100 250;
#X obj 128 584 noteout;
#X obj 129 375 t f f f, f 52;
#N canvas -1280 581 334 216 reset_&_resize_array 0;
#X obj 60 34 inlet;
#X obj 137 27 sel 0;
#X obj 137 48 int \$0;
#X obj 61 79 + 1;
#X obj 61 56 t f f;
#X msg 137 69 \; \$1-norgard const 0;
#X obj 61 103 array size \$0-norgard;
#X connect 0 0 4 0;
#X connect 1 0 2 0;
#X connect 2 0 5 0;
#X connect 3 0 6 0;
#X connect 4 0 3 0;
#X connect 4 1 1 0;
#X restore 437 403 pd reset_&_resize_array;
#N canvas -1280 581 1027 362 writeSequence 0;
#X obj 226 16 inlet;
#X obj 226 60 sel 0, f 39;
#X msg 226 81 0;
#X text 7 84 if input (i.e. step) is 0 \, output 0;
#X obj 455 79 t f f, f 7;
#X obj 455 102 % 2, f 4;
#X text 268 100 mod2: odds are 1 \, evens 0 --->;
#X obj 455 123 pack, f 7;
#X obj 455 144 route 0 1, f 49;
#X text 392 161 evens;
#X obj 455 165 / 2;
#X obj 455 186 tabread \$0-norgard, f 11;
#X obj 455 238 * -1;
#X obj 226 36 t f f, f 116;
#X obj 455 309 tabwrite \$0-norgard, f 78;
#X text 239 186 get the value at (current index/2);
#X text 239 200 and multiply it by minus 1;
#X obj 600 185 / 2;
#X obj 600 206 tabread \$0-norgard, f 11;
#X obj 600 165 - 1;
#X obj 600 238 + 1;
#X text 655 169 odds;
#X text 673 201 get the value at ((current index-1)/2);
#X text 672 214 and add 1 to it;
#X connect 0 0 13 0;
#X connect 1 0 2 0;
#X connect 1 1 4 0;
#X connect 2 0 14 0;
#X connect 4 0 5 0;
#X connect 4 1 7 1;
#X connect 5 0 7 0;
#X connect 7 0 8 0;
#X connect 8 0 10 0;
#X connect 8 1 19 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 12 0 14 0;
#X connect 13 0 1 0;
#X connect 13 1 14 1;
#X connect 17 0 18 0;
#X connect 18 0 20 0;
#X connect 19 0 17 0;
#X connect 20 0 14 0;
#X restore 286 407 pd writeSequence;
#X obj 45 402 vradio 15 1 0 2 empty empty empty 0 -8 0 10 -262144 -1
-1 1;
#X text 60 397 chromatic;
#X text 62 417 scale;
#X obj 129 441 int;
#X obj 129 396 t b f;
#X obj 129 461 pack;
#X obj 129 480 route 0 1;
#X obj 158 418 tabread \$0-norgard, f 10;
#X text 86 186 http://oeis.org/search?q=A004718&sort=&language=&go=Search
;
#X connect 9 0 17 0;
#X connect 10 0 14 0;
#X connect 14 0 15 0;
#X connect 15 0 16 0;
#X connect 15 1 16 1;
#X connect 17 0 24 0;
#X connect 17 1 19 0;
#X connect 17 2 18 0;
#X connect 20 0 23 1;
#X connect 23 0 25 0;
#X connect 24 0 23 0;
#X connect 24 1 27 0;
#X connect 25 0 26 0;
#X connect 26 0 14 0;
#X connect 26 1 10 0;
#X connect 27 0 25 1;
#X restore 77 75 pd infinite_series;
#X text 64 119 Recamán Sequence;
#N canvas 357 71 948 609 recaman_series 0;
#N canvas 0 23 450 278 (subpatch) 0;
#X array \$0-recaman 17 float 3;
#A 0 0 1 3 6 2 7 13 20 12 21 11 22 10 23 9 24 8;
#X coords 0 127 17 0 200 140 1 0 0;
#X restore 600 85 graph;
#X obj 156 495 makenote 100 250;
#X obj 156 516 noteout;
#X text 64 397 play me -->;
#X text 83 9 The Recaman Sequence is a famous integer sequence based
on a simple idea always go back unless you can't \, then go forward
;
#X obj 156 455 tabread \$0-recaman;
#X text 96 260 The rules go as follows:;
#X text 99 277 a(0) = 0 \;;
#X text 100 294 for n > 0 \, a(n) = a(n-1) - n if nonnegative and not
already in the sequence;
#X text 101 323 otherwise a(n) = a(n-1) + n;
#X text 83 56 https://www.youtube.com/watch?v=FGC5TdIiT9U;
#X text 86 39 http://oeis.org/A005132;
#X text 88 74 So basically we start with 0 (at index 0);
#X text 87 90 at index 1 we can't go backwards (no negatives) so we
go forward (0+1 = 1 \; so we have 1 at index 1);
#X text 87 124 at index 2 we can't go backwards (last value was 1 \;
1-2 ==-1 and we can't have negatives) so we go forward (1+2 = 3 \;
so we have 3 at index 2);
#X text 87 169 at index 3 we can't go backwards (last value was 3 \;
3-3 ==0 and we already had a 0 at index 0) so we go forward (3 + 3
= 6 \; so we have 6 at index 3);
#X text 89 213 finally at index 4 we go backwards ad have 2 (6-4 ==
2);
#X text 96 237 Again it's actually easier to use the mathematical notation
to figure out how to code it;
#X text 495 243 This is a little bit more complex than the infinity
series because we need to look through the list each time to make sure
the value hasn't been used...;
#X obj 156 474 + 0;
#X text 494 280 My technique is not the most efficient but hopefully
it is clear;
#N canvas -1280 581 1056 375 writePattern 0;
#X obj 271 70 inlet;
#X obj 271 111 sel 0, f 9;
#X floatatom 271 89 5 0 0 0 - - -;
#X obj 322 255 tabwrite \$0-recaman, f 10;
#X msg 271 132 0 0;
#X text 13 132 1 - if input (i.e. index) is 0 \, value is 0;
#N canvas -1093 887 523 201 set_to_a(n-1)-n 0;
#X obj 37 37 inlet;
#X obj 37 58 t f f, f 17;
#X obj 37 128 -, f 12;
#X obj 37 99 tabread \$0-recaman, f 11;
#X obj 37 79 - 1;
#X obj 37 149 pack, f 17;
#X text 149 57 2 - if index is not zero \, set the value to be the
value at the previous index minus the current index;
#X text 150 83 we'll correct for negative and already used values afterwards
;
#X obj 37 170 outlet;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 1 1 2 1;
#X connect 1 1 5 1;
#X connect 2 0 5 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 5 0 8 0;
#X restore 617 197 pd set_to_a(n-1)-n;
#X f 16;
#N canvas 445 87 619 284 correct_for_negatives_or_already_used_values
0;
#X obj 38 36 inlet;
#X obj 134 126 t f f, f 17;
#X obj 134 167 tabread \$0-recaman, f 11;
#X obj 134 147 - 1;
#X obj 134 217 pack, f 17;
#X obj 134 196 +, f 12;
#X obj 38 57 t f f, f 43;
#N canvas 0 23 450 300 check_for_negative_value 0;
#X obj 37 37 inlet;
#X obj 37 78 tabread \$0-recaman, f 11;
#X obj 37 57 t f f, f 14;
#X obj 37 110 < 0;
#X obj 37 131 pack, f 14;
#X obj 37 152 route 1;
#X obj 37 173 outlet;
#X text 118 28 First we check if the value just stored is negative
;
#X text 97 153 the route object only outputs the index if the previously
stored value is negative;
#X connect 0 0 2 0;
#X connect 1 0 3 0;
#X connect 2 0 1 0;
#X connect 2 1 4 1;
#X connect 3 0 4 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X restore 265 78 pd check_for_negative_value;
#N canvas -863 581 514 300 check_if_value 0;
#X obj 37 37 inlet;
#X obj 36 138 tabread \$0-recaman, f 10;
#X obj 36 191 pack, f 27;
#X obj 36 212 route 1;
#X obj 37 115 uzi_sjf;
#X obj 36 170 ==, f 12;
#X obj 106 107 tabread \$0-recaman, f 10;
#X obj 37 97 - 1;
#X obj 37 79 t f f f, f 27;
#X obj 36 233 outlet;
#X text 94 213 the route object only outputs the index if the last
stored value was never in the pattern before;
#X text 118 28 We check if the value just stored was in the pattern
before by simply iterating through all of the previous entries;
#X connect 0 0 8 0;
#X connect 1 0 5 0;
#X connect 2 0 3 0;
#X connect 3 0 9 0;
#X connect 4 2 1 0;
#X connect 5 0 2 0;
#X connect 6 0 5 1;
#X connect 7 0 4 0;
#X connect 8 0 7 0;
#X connect 8 1 6 0;
#X connect 8 2 2 1;
#X restore 38 78 pd check_if_value is already in_list;
#X f 19;
#X text 254 134 If value at index is negative \, or already appeared
in sequence set value to a(n-1)+n instead;
#X obj 134 238 outlet;
#X connect 0 0 6 0;
#X connect 1 0 3 0;
#X connect 1 1 4 1;
#X connect 1 1 5 1;
#X connect 2 0 5 0;
#X connect 3 0 2 0;
#X connect 4 0 10 0;
#X connect 5 0 4 0;
#X connect 6 0 8 0;
#X connect 6 1 7 0;
#X connect 7 0 1 0;
#X connect 8 0 1 0;
#X restore 322 193 pd correct_for_negatives_or_already_used_values
;
#X f 22;
#X obj 322 133 t f f, f 71;
#X text 634 165 2 - if index is not zero \, set the value to be the
value at the previous index minus the current index;
#X text 338 160 3 - correct if value was already used \,;
#X text 347 171 or it was negative;
#X text 456 16 I've broken the problem of writing the sequence into
three (well 5 actually...) steps;
#X connect 0 0 2 0;
#X connect 1 0 4 0;
#X connect 1 1 8 0;
#X connect 2 0 1 0;
#X connect 4 0 3 0;
#X connect 6 0 3 0;
#X connect 7 0 3 0;
#X connect 8 0 7 0;
#X connect 8 1 6 0;
#X restore 275 454 pd writePattern;
#X obj 156 423 t f f f, f 49;
#N canvas -1280 581 334 216 reset_&_resize_array 0;
#X obj 60 34 inlet;
#X obj 137 27 sel 0;
#X obj 137 48 int \$0;
#X msg 137 69 \; \$1-recaman const 0;
#X obj 61 103 array size \$0-recaman;
#X obj 61 79 + 1;
#X obj 61 56 t f f;
#X connect 0 0 6 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 5 0 4 0;
#X connect 6 0 5 0;
#X connect 6 1 1 0;
#X restore 426 453 pd reset_&_resize_array;
#X obj 156 358 conductor_sjf 250 68;
#X text 555 12 I've limited this to 68 steps \, but it does go on for
ever \, unlike the infinite series though it just gets higher and higher
and higher....;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 5 0 19 0;
#X connect 19 0 1 0;
#X connect 22 0 5 0;
#X connect 22 1 21 0;
#X connect 22 2 23 0;
#X connect 24 0 22 0;
#X restore 77 138 pd recaman_series;
#X text 31 34 ------------------------------------------------------------
;
#X text 32 106 ------------------------------------------------------------
;
#X text 23 4 Here I am just generating well known mathematical number
sequences and using them as melodic material;
#X text 33 161 ------------------------------------------------------------
;
#X text 70 175 Visit: http://oeis.org;
#X text 69 188 Try and create algorithms to generate other number sequences
(e.g. fibonacci \, A025480);
#X text 71 213 You could also explore: http://repmus.ircam.fr/_media/mamux/saisons/saison06-2006-2007/johnson-2006-10-14.pdf
;
#X restore 106 262 pd integer_sequences;
#X text 80 282 ------------------------------------------------------------
;
#X text 106 299 Serialism;
#N canvas 146 23 1134 750 serialism 0;
#X text 145 581 ------------------------------------------------------------
;
#X text 23 4 Serialism is a copmpositional technique whereby a sequence
of pitches (called a tone row);
#X text 24 31 Is used as the basis for an entire piece;
#X text 25 49 Traditionally a tone row would use all of the notes of
the chromatic scale \, and each note would only be used once in the
row;
#X text 27 112 1 - retrograde (reverse the row);
#X text 27 128 2 - invert (flipthe row upside down \, so instead of
going up x semitones go down x semitone \, and vice versa);
#X text 28 156 3 - transpose by some number of semitones;
#X obj 952 161 bng 15 250 50 0 empty empty generate_tone_row 17 7 0
10 -262144 -1 -1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-toneRow 12 float 3;
#A 0 7 2 4 0 11 10 3 9 8 1 5 6;
#X coords 0 12 12 0 133 60 1 0 0;
#X restore 448 82 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-inversion 12 float 3;
#A 0 7 12 10 14 3 4 11 5 6 13 9 8;
#X coords 0 24 12 -12 133 180 1 0 0;
#X restore 581 22 graph;
#X obj 193 226 conductor_sjf 250 12;
#X obj 193 291 t b f;
#X obj 193 319 int;
#X obj 193 340 pack;
#X obj 148 235 vradio 15 1 0 4 empty empty empty 0 -8 0 10 -262144
-1 -1 3;
#X text 116 233 row;
#X text 74 249 retrograde;
#X text 26 95 Variation is created through a number of simple proceedures
;
#X text 28 173 4 - combining the above (e.g.retrograde & inversion)
;
#X text 79 263 inversion;
#X text 14 281 retrograde inversion;
#X obj 193 361 route 0 1 2 3, f 68;
#X obj 193 484 tabread \$0-toneRow;
#X obj 314 521 + 60;
#X obj 314 542 makenote 100 250;
#X obj 314 563 noteout;
#X obj 294 386 t b f, f 10;
#X obj 294 448 -, f 10;
#X obj 294 407 int 12;
#X obj 294 428 - 1;
#X obj 817 160 bng 15 250 50 0 empty empty generate_inversion 17 7
0 10 -262144 -1 -1;
#N canvas 0 23 450 300 writeToneRow 0;
#X obj 37 37 inlet;
#X obj 37 78 uzi_sjf 12;
#X obj 35 145 pack, f 28;
#X obj 35 101 t b f, f 28;
#X obj 35 167 tabwrite \$0-toneRow;
#X obj 35 124 urn_sjf 12;
#X obj 37 58 t b b, f 27;
#X connect 0 0 6 0;
#X connect 1 2 3 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 3 1 2 1;
#X connect 5 0 2 0;
#X connect 6 0 1 0;
#X connect 6 1 5 2;
#X restore 952 181 pd writeToneRow;
#N canvas 0 23 378 300 writeInversion 0;
#X obj 42 16 inlet;
#X obj 41 37 uzi_sjf 12;
#X obj 41 66 sel 0, f 22;
#X obj 41 128 tabread \$0-toneRow, f 10;
#X msg 41 87 0;
#X obj 41 108 t f f, f 12;
#X obj 41 165 pack, f 12;
#X obj 41 256 tabwrite \$0-inversion;
#X obj 145 120 tabread \$0-toneRow, f 10;
#X obj 212 158 tabread \$0-toneRow, f 10;
#X obj 145 157 -;
#X obj 145 178 * -1;
#X obj 145 199 +;
#X obj 145 220 pack, f 23;
#X obj 145 96 t f b f, f 23;
#X msg 212 120 0;
#X connect 0 0 1 0;
#X connect 1 2 2 0;
#X connect 2 0 4 0;
#X connect 2 1 14 0;
#X connect 3 0 6 0;
#X connect 4 0 5 0;
#X connect 5 0 3 0;
#X connect 5 1 6 1;
#X connect 6 0 7 0;
#X connect 8 0 10 0;
#X connect 9 0 10 1;
#X connect 9 0 12 1;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 13 0 7 0;
#X connect 14 0 8 0;
#X connect 14 1 15 0;
#X connect 14 2 13 1;
#X connect 15 0 9 0;
#X restore 817 180 pd writeInversion;
#X obj 395 484 tabread \$0-inversion;
#X obj 496 382 t b f, f 10;
#X obj 496 444 -, f 10;
#X obj 496 403 int 12;
#X obj 496 424 - 1;
#X obj 817 103 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 817 123 t b b, f 23;
#X text 178 600 Serialism examples;
#N canvas 51 23 916 619 serialism_2 0;
#X obj 282 135 t f f, f 52;
#X obj 556 156 stpseq16_sjf;
#X obj 714 499 s \$0-uniqueID;
#X obj 282 251 serialiser_sjf, f 16;
#X msg 334 227 \$1-pitch;
#X obj 334 206 r \$0-uniqueID;
#X obj 423 252 serialiser_sjf;
#X obj 465 207 r \$0-uniqueID;
#X msg 465 227 \$1-velocity;
#X obj 282 156 t f f, f 24;
#X obj 282 304 pack;
#X obj 325 304 pack;
#X obj 376 304 pack;
#X obj 282 323 unpack;
#X obj 282 367 pack, f 6;
#X obj 353 577 makenote 100 250;
#X obj 353 598 noteout;
#X obj 282 70 conductor_sjf 250 16;
#X obj 145 319 vradio 15 1 1 4 empty empty empty 0 -8 0 10 -262144
-1 -1 0;
#X text 71 333 retrograde;
#X text 76 347 inversion;
#X text 11 365 retrograde inversion;
#X obj 325 323 unpack;
#X obj 325 367 pack, f 6;
#X obj 376 323 unpack;
#X obj 376 367 pack, f 6;
#X obj 543 514 == 0;
#X obj 506 535 spigot;
#X obj 441 535 spigot;
#X obj 375 535 spigot;
#X obj 408 514 == 1;
#X obj 282 344 + 36;
#X obj 376 344 + 36;
#X obj 325 344 + 36;
#X obj 474 514 == 2;
#X obj 310 535 spigot;
#X obj 343 514 == 3;
#X text 27 5 This example reads the melody from my sequencer and applies
the three tranformstions we have seen before to both the midi pitches
and velocities;
#X floatatom 808 522 5 0 0 0 - - -;
#X text 83 318 Original;
#X connect 0 0 9 0;
#X connect 0 1 1 0;
#X connect 1 0 27 0;
#X connect 1 1 2 0;
#X connect 1 1 38 0;
#X connect 3 0 10 0;
#X connect 3 1 11 0;
#X connect 3 2 12 0;
#X connect 4 0 3 1;
#X connect 5 0 4 0;
#X connect 6 0 10 1;
#X connect 6 1 11 1;
#X connect 6 2 12 1;
#X connect 7 0 8 0;
#X connect 8 0 6 1;
#X connect 9 0 3 0;
#X connect 9 1 6 0;
#X connect 10 0 13 0;
#X connect 11 0 22 0;
#X connect 12 0 24 0;
#X connect 13 0 31 0;
#X connect 13 1 14 1;
#X connect 14 0 35 0;
#X connect 15 0 16 0;
#X connect 15 1 16 1;
#X connect 17 0 0 0;
#X connect 18 0 26 0;
#X connect 18 0 34 0;
#X connect 18 0 30 0;
#X connect 18 0 36 0;
#X connect 22 0 33 0;
#X connect 22 1 23 1;
#X connect 23 0 29 0;
#X connect 24 0 32 0;
#X connect 24 1 25 1;
#X connect 25 0 28 0;
#X connect 26 0 27 1;
#X connect 27 0 15 0;
#X connect 28 0 15 0;
#X connect 29 0 15 0;
#X connect 30 0 29 1;
#X connect 31 0 14 0;
#X connect 32 0 25 0;
#X connect 33 0 23 0;
#X connect 34 0 28 1;
#X connect 35 0 15 0;
#X connect 36 0 35 1;
#X restore 191 643 pd serialism_2;
#N canvas 88 225 1019 651 serialism_1 0;
#X obj 347 140 conductor_sjf 250 12;
#X obj 347 338 int;
#X obj 347 359 pack;
#X obj 347 431 makenote 100 250;
#X obj 347 452 noteout;
#X obj 627 177 sel 0;
#N canvas 0 23 463 317 read_Row 0;
#X obj 37 37 inlet;
#X obj 37 58 pack;
#X obj 37 79 route 0 1 2 3, f 68;
#X obj 37 202 tabread \$0-toneRow;
#X obj 138 104 t b f, f 10;
#X obj 138 166 -, f 10;
#X obj 138 125 int 12;
#X obj 138 146 - 1;
#X obj 239 202 tabread \$0-inversion;
#X obj 340 100 t b f, f 10;
#X obj 340 162 -, f 10;
#X obj 340 121 int 12;
#X obj 340 142 - 1;
#X obj 37 235 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 2 2 8 0;
#X connect 2 3 9 0;
#X connect 3 0 13 0;
#X connect 4 0 6 0;
#X connect 4 1 5 1;
#X connect 5 0 3 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 8 0 13 0;
#X connect 9 0 11 0;
#X connect 9 1 10 1;
#X connect 10 0 8 0;
#X connect 11 0 12 0;
#X connect 12 0 10 0;
#X restore 347 382 pd read_Row;
#X obj 627 198 counter_sjf 12;
#N canvas 0 23 463 317 read_Row 0;
#X obj 37 37 inlet;
#X obj 37 58 pack;
#X obj 37 79 route 0 1 2 3, f 68;
#X obj 37 202 tabread \$0-toneRow;
#X obj 138 104 t b f, f 10;
#X obj 138 166 -, f 10;
#X obj 138 125 int 12;
#X obj 138 146 - 1;
#X obj 239 202 tabread \$0-inversion;
#X obj 340 100 t b f, f 10;
#X obj 340 162 -, f 10;
#X obj 340 121 int 12;
#X obj 340 142 - 1;
#X obj 37 235 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 2 2 8 0;
#X connect 2 3 9 0;
#X connect 3 0 13 0;
#X connect 4 0 6 0;
#X connect 4 1 5 1;
#X connect 5 0 3 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 8 0 13 0;
#X connect 9 0 11 0;
#X connect 9 1 10 1;
#X connect 10 0 8 0;
#X connect 11 0 12 0;
#X connect 12 0 10 0;
#X restore 628 297 pd read_Row;
#X f 8;
#X obj 347 308 t b f, f 8;
#X obj 347 205 t f f, f 44;
#X obj 347 403 +, f 44;
#X obj 608 374 + 60;
#X obj 503 286 % 4;
#X obj 628 253 int, f 10;
#X obj 628 274 pack, f 8;
#X obj 628 223 t b f, f 8;
#X obj 735 224 sel 0;
#X obj 735 245 counter_sjf 12;
#N canvas 0 23 463 317 read_Row 0;
#X obj 37 37 inlet;
#X obj 37 58 pack;
#X obj 37 79 route 0 1 2 3, f 68;
#X obj 37 202 tabread \$0-toneRow;
#X obj 138 104 t b f, f 10;
#X obj 138 166 -, f 10;
#X obj 138 125 int 12;
#X obj 138 146 - 1;
#X obj 239 202 tabread \$0-inversion;
#X obj 340 100 t b f, f 10;
#X obj 340 162 -, f 10;
#X obj 340 121 int 12;
#X obj 340 142 - 1;
#X obj 37 235 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 2 2 8 0;
#X connect 2 3 9 0;
#X connect 3 0 13 0;
#X connect 4 0 6 0;
#X connect 4 1 5 1;
#X connect 5 0 3 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 8 0 13 0;
#X connect 9 0 11 0;
#X connect 9 1 10 1;
#X connect 10 0 8 0;
#X connect 11 0 12 0;
#X connect 12 0 10 0;
#X restore 736 344 pd read_Row;
#X obj 736 300 int, f 10;
#X obj 736 321 pack, f 8;
#X obj 736 270 t b f, f 8;
#X obj 735 384 % 4;
#X obj 875 240 sel 0;
#X obj 875 261 counter_sjf 12;
#N canvas 0 23 463 317 read_Row 0;
#X obj 37 37 inlet;
#X obj 37 58 pack;
#X obj 37 79 route 0 1 2 3, f 68;
#X obj 37 202 tabread \$0-toneRow;
#X obj 138 104 t b f, f 10;
#X obj 138 166 -, f 10;
#X obj 138 125 int 12;
#X obj 138 146 - 1;
#X obj 239 202 tabread \$0-inversion;
#X obj 340 100 t b f, f 10;
#X obj 340 162 -, f 10;
#X obj 340 121 int 12;
#X obj 340 142 - 1;
#X obj 37 235 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 2 2 8 0;
#X connect 2 3 9 0;
#X connect 3 0 13 0;
#X connect 4 0 6 0;
#X connect 4 1 5 1;
#X connect 5 0 3 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 8 0 13 0;
#X connect 9 0 11 0;
#X connect 9 1 10 1;
#X connect 10 0 8 0;
#X connect 11 0 12 0;
#X connect 12 0 10 0;
#X restore 876 360 pd read_Row;
#X obj 876 316 int;
#X obj 876 337 pack;
#X obj 876 286 t b f, f 8;
#X floatatom 575 340 5 0 0 0 - - -;
#X obj 503 261 + 12;
#X obj 736 366 + 12;
#X obj 876 379 + 12;
#X obj 876 400 % 4;
#X obj 553 317 vradio 15 1 0 4 empty empty empty 0 -8 0 10 -262144
-1 -1 3;
#X text 521 315 row;
#X text 479 331 retrograde;
#X text 484 345 inversion;
#X text 419 363 retrograde inversion;
#X text 61 34 This example uses the row created in the previous patchto
determine not only the pitch \, but also transpositions \, and changes
between the original row \, inversions \, retrogrades \, etc;
#X connect 0 0 10 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 3 0 4 0;
#X connect 3 1 4 1;
#X connect 5 0 7 0;
#X connect 6 0 11 0;
#X connect 7 0 16 0;
#X connect 7 0 17 0;
#X connect 8 0 12 0;
#X connect 8 0 30 0;
#X connect 8 0 31 0;
#X connect 9 0 1 0;
#X connect 9 1 2 1;
#X connect 10 0 9 0;
#X connect 10 1 5 0;
#X connect 11 0 3 0;
#X connect 12 0 11 1;
#X connect 13 0 1 1;
#X connect 13 0 35 0;
#X connect 14 0 15 0;
#X connect 15 0 8 0;
#X connect 16 0 14 0;
#X connect 16 1 15 1;
#X connect 17 0 18 0;
#X connect 18 0 22 0;
#X connect 18 0 24 0;
#X connect 19 0 32 0;
#X connect 20 0 21 0;
#X connect 21 0 19 0;
#X connect 22 0 20 0;
#X connect 22 1 21 1;
#X connect 23 0 14 1;
#X connect 24 0 25 0;
#X connect 25 0 29 0;
#X connect 26 0 33 0;
#X connect 27 0 28 0;
#X connect 28 0 26 0;
#X connect 29 0 27 0;
#X connect 29 1 28 1;
#X connect 31 0 13 0;
#X connect 32 0 23 0;
#X connect 33 0 34 0;
#X connect 34 0 20 1;
#X restore 191 622 pd serialism_1;
#X connect 7 0 31 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 11 1 13 1;
#X connect 12 0 13 0;
#X connect 13 0 21 0;
#X connect 14 0 12 1;
#X connect 21 0 22 0;
#X connect 21 1 26 0;
#X connect 21 2 33 0;
#X connect 21 3 34 0;
#X connect 22 0 23 0;
#X connect 23 0 24 0;
#X connect 24 0 25 0;
#X connect 24 1 25 1;
#X connect 26 0 28 0;
#X connect 26 1 27 1;
#X connect 27 0 22 0;
#X connect 28 0 29 0;
#X connect 29 0 27 0;
#X connect 30 0 32 0;
#X connect 33 0 23 0;
#X connect 34 0 36 0;
#X connect 34 1 35 1;
#X connect 35 0 33 0;
#X connect 36 0 37 0;
#X connect 37 0 35 0;
#X connect 38 0 39 0;
#X connect 39 0 30 0;
#X connect 39 1 7 0;
#X restore 105 318 pd serialism;
#X text 88 37 NOTE: If SimpleSynth was not open before you opened PD
you will need to close PD \, open SimpleSynth \, and reopen PD;
#X text 88 66 NOTE: In the Media menu (along the top ^^^) go to MIDI
Settings and make sure SimpleSynth is selected;
